
mutable struct EntInfo 
    nodes::Array
    message::String
    stamps::Dict
    sim::Simulation
    function EntInfo(nodes::Array, message::String)
        return new(nodes, message, Dict{Symbol, Real}())
    end
    function EntInfo(nodes::Array)
        return new(nodes, "pending", Dict{Symbol, Real}())
    end
    function EntInfo(nodes::Array, stamps::Dict)
        return new(nodes, "pending", stamps)
    end
    function EntInfo(nodes::Array, message::String, stamps::Dict)
        return new(nodes, message, stamps)
    end
end

messages = Dict(
    :ENT => "succesful entanglement generated",
    :LOK => "locked pair and searching for purification sacrificial pairs",
    :PAIR => "found sacrificial pairs, prepeaing for purification"
)

function stamp!(entinfo::EntInfo, step::Symbol, message::String="")
    entinfo.message = messages[step]
    if message != ""
        entinfo.message = entinfo.message * " : " * message
    end
    entinfo.stamps[step] = now(sim)
end

entanglement_status = Dict{Float16, EntInfo}()

using Crayons
using Crayons.Box
function statusinfo(entinfo::EntInfo)
    println(BLUE_FG("$(entinfo.nodes[1][1]:entinfo.nodes[1][2]) & $(entinfo.nodes[2][1]:entinfo.nodes[2][2])  |  "))
    println(entinfo.message)
    for item in entinfo.stamps
        print("\t\t ")
        print(BLUE_FG(string(item.first)))
        print(BLUE_FG(" @"))
        print(item.second)
        println()
    end
end


mutable struct Channel
    env::Simulation
    delay::Float64
    store::Array{Store{Dict{Symbol,Real}}}
    
    function Channel(env::Simulation, delay::Float64, storage=1)
        return new(env, delay, [Store{Dict{Symbol,Real}}(env) for _ in 1:storage])
    end
end

@resumable function latency(env::Simulation, channel::Channel, value)
    @yield timeout(channel.env, channel.delay)
    @yield put!(haskey(value, :slot) ? channel.store[value[:slot]] : channel.store[1], value)
end

function put!(channel::Channel, value, slot=1)
    value[:slot] = slot
    @process latency(channel.env, channel, value) # results in the scheduling of all events generated by latency
end

function take!(channel::Channel, slot=1); output = false
    take!(channel.store[slot]) # returns an element stored in the cable store
end

using Printf
Base.show(io::IO, f::Float16) = print(io, RED_FG(@sprintf("%.3f",f)))
Base.show(io::IO, f::Float64) = print(io, GREEN_FG(@sprintf("%.3f",f)))

