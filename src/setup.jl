# For convenient graph data structures
using Graphs

# For discrete event simulation
using ResumableFunctions
using ConcurrentSim
import Base: put!, take!

# Useful for interactive work
# Enables automatic re-compilation of modified codes
using Revise

# The workhorse for the simulation
using QuantumSavory

# Predefined useful circuits
using QuantumSavory.CircuitZoo: EntanglementSwap, Purify2to1

mutable struct EntInfo 
    nodes::Array
    message::String
    stamps::Dict
    sim::Simulation
    function EntInfo(nodes::Array, message::String)
        return new(nodes, message, Dict{Symbol, Real}())
    end
    function EntInfo(nodes::Array)
        return new(nodes, "pending", Dict{Symbol, Real}())
    end
    function EntInfo(nodes::Array, stamps::Dict)
        return new(nodes, "pending", stamps)
    end
    function EntInfo(nodes::Array, message::String, stamps::Dict)
        return new(nodes, message, stamps)
    end
end

function stamp!(entinfo::EntInfo, step::Symbol)
    if step == :ENT
        entinfo.message = "succesful"
    end
    entinfo.stamps[step] = now(sim)
end

entanglement_status = Dict{Float16, EntInfo}()

mutable struct Channel
    env::Simulation
    delay::Float64
    store::Array{Store{Dict{Symbol,Real}}}
    
    function Channel(env::Simulation, delay::Float64, storage=1)
        return new(env, delay, [Store{Dict{Symbol,Real}}(env) for _ in 1:storage])
    end
end

@resumable function latency(env::Simulation, channel::Channel, value)
    @yield timeout(channel.env, channel.delay)
    @yield put!(haskey(value, :slot) ? channel.store[value[:slot]] : channel.store[1], value)
end

function put!(channel::Channel, value)
    @process latency(channel.env, channel, value) # results in the scheduling of all events generated by latency
end

function put!(channel::Channel, value, slot)
    value[:slot] = slot
    @process latency(channel.env, channel, value) # results in the scheduling of all events generated by latency
end

function take!(channel::Channel, slot=1); output = false
    take!(channel.store[slot]) # returns an element stored in the cable store
end

using Printf
Base.show(io::IO, f::Float64) = @printf(io, "%.3f", f)
Base.show(io::IO, f::Float16) = @printf(io, "%.3f", f)

const perfect_pair = (Z1⊗Z1 + Z2⊗Z2) / sqrt(2)
const perfect_pair_dm = SProjector(perfect_pair)
const mixed_dm = MixedState(perfect_pair_dm)
noisy_pair_func(F) = F*perfect_pair_dm + (1-F)*mixed_dm # TODO make a depolarization helper
noisy_pair = noisy_pair_func(0.5)

function findfreequbit(network, node)
    register = network[node]
    regsize = nsubsystems(register)
    findfirst(i->!isassigned(register,i) && !islocked(register[i]), 1:regsize)
end

@resumable function sender_signalfreequbit(env::Simulation, network, channel::Channel, node, waittime=0., busytime=0.)
    while true
        entid = rand(Float16)
        i = findfreequbit(network, node)
        if isnothing(i)
            @yield timeout(sim, waittime)
            println("id:$entid&m:NTHS       $node] @ $(now(env))\t> Nothing found in node [$node]")
            continue
        end

        slot = network[node,i]
        @yield request(slot)
        register = network[node]
        @yield timeout(sim, busytime)

        value = Dict(:time=>now(env), :node=>node, :index=>i, :message=>1, :entid=>entid)
        put!(channel, value, 1) # [1] -- found free at sender
    end
end

@resumable function sender_waitforfreequbitback(env::Simulation, network, channel::Channel, node, waittime=0., busytime=0.)
    while true
        msg = @yield take!(channel, 2) # [2]
        i = msg[:i]
        println("id:$(msg[:entid])&m:ASGR [$node <- $(msg[:node])] @ $(now(env))\t> Assigned $(msg[:node]):$(msg[:index]) to $node:$i\t\t | (msg=$(msg[:message]))")

        # Assign the qubit
        network[node,:enttrackers][i] = (msg[:node],msg[:index])

        value = Dict(:time=>now(env), :node=>node, :index=>i, :i=>msg[:index], :message=>3, :entid=>msg[:entid])
        put!(channel, value, 3)
    end
end


@resumable function receiver_findfreequbit(env::Simulation, network, channel::Channel, node, waittime=0., busytime=0.)
    while true
        msg = @yield take!(channel, 1) # [1]
        println("\nid:$(msg[:entid])&m:FNDS [ ENT  ] > Entangler triggered at $(msg[:time]), node [$(msg[:node])]\t\t | (msg=$(msg[:message]))")
        println("id:$(msg[:entid])&m:____ [$node <- $(msg[:node])] @ $(now(env))\t> Free at $(msg[:node]):$(msg[:index])")
        println("id:$(msg[:entid])&m:____       $node] @ $(now(env))\t> Searching in node [$node]")

        i = findfreequbit(network, node)
        if isnothing(i)
            @yield timeout(sim, waittime)
            println("id:$(msg[:entid])&m:NTHR       $node] @ $(now(env))\t> Nothing found in node [$node]")
            
            # TODO: send message to sender to unlock itself []
            unlock(network[msg[:node]][msg[:index]])
            println("id:$(msg[:entid])&m:UNLK       $node] @ $(now(env))\t> Unlocked $(msg[:node]):$(msg[:index])")
            continue
        end
        
        slot = network[node,i]
        @yield request(slot)
        register = network[node]
        @yield timeout(sim, busytime)
        println("id:$(msg[:entid])&m:FNDR       $node] @ $(now(env))\t> Found $(node):$i")

        # Assign the qubit
        network[node,:enttrackers][i] = (msg[:node],msg[:index])

        value = Dict(:time=>now(env), :node=>node, :index=>i, :i=>msg[:index], :message=>2, :entid=>msg[:entid])
        put!(channel, value, 2) # [2] -- found free at receiver
    end
end


@resumable function receiver_assignfoundqubit(env::Simulation, network, channel::Channel, node, waittime=0., busytime=0.)
    while true
        msg = @yield take!(channel, 3) # [3]

        i = msg[:i]
        println("id:$(msg[:entid])&m:ASGS [$node <- $(msg[:node])] @ $(now(env))\t> Assigned $(msg[:node]):$(msg[:index]) to $node:$i\t\t | (msg=$(msg[:message]))")

        initialize!((network[node][i],network[msg[:node]][msg[:index]]),noisy_pair; time=now(sim))
        # initialize [find a way to do this locally using another node??]
        println("id:$(msg[:entid])&m:ENT% [$node: $(msg[:node]),$node] @ $(now(env))\t> Entangled node $(node):$(i) and node $(msg[:node]):$(msg[:index])")
        
        # Log succesfull entanglement
        entanglement_status[msg[:entid]] = EntInfo([[node, i], [msg[:node], msg[:index]]])
        entanglement_status[msg[:entid]].sim = env
        stamp!(entanglement_status[msg[:entid]], :ENT)

        unlock(network[node][i])
        unlock(network[msg[:node]][msg[:index]])
    end
end

function simulation_setup(sizeA, sizeB, commtimes)
    registers = Register[]
    push!(registers, Register(sizeA))
    push!(registers, Register(sizeB))
    sizes = [sizeA, sizeB]


    graph = grid([2])
    network = RegisterNet(graph, registers)
    sim = get_time_tracker(network)

    # Set up the chhannel communicating between nodes 1 and 2
    network[(1, 2), :channel] = [Channel(sim, commtimes[i], 6) for i in 1:2]

    for v in vertices(network)
        # Create an array specifying whether a qubit is entangled with another qubit
        network[v,:enttrackers] = Any[nothing for i in 1:sizes[v]]
    end

    sim, network
end
